<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover" />
<title>Invader Stable v6 + Stick + Pause (iOS26 No-Zoom)</title>
<style>
  html,body{
    margin:0;padding:0;background:#000;overflow:hidden;
    touch-action:none;
    overscroll-behavior:none;
    -webkit-overflow-scrolling:auto; /* iOS系での挙動安定 */
    -webkit-text-size-adjust:100%;
  }
  canvas{position:fixed;inset:0;display:block;touch-action:none;pointer-events:auto}

  #hud{
    position:fixed;top:8px;left:8px;z-index:10;color:#fff;
    font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    user-select:none;pointer-events:none;
  }

  #pauseBtn{
    position:fixed;top:10px;right:10px;z-index:80;
    padding:8px 12px;font:700 14px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#fff;background:rgba(0,0,0,.55);
    border:2px solid rgba(255,255,255,.25);border-radius:10px;
    cursor:pointer;pointer-events:auto;user-select:none;
    touch-action:manipulation;
    -webkit-tap-highlight-color: transparent;
  }

  #msg{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    color:#fff;font:700 40px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    text-shadow:0 2px 0 rgba(0,0,0,.5);
    z-index:40;pointer-events:none;text-align:center;white-space:pre-line;
  }

  /* ===== Mobile controls ===== */
  .controls{position:fixed;inset:0;z-index:70;pointer-events:none}

  #stickBase,#stickKnob{
    position:fixed;border-radius:50%;
    pointer-events:auto;
    touch-action:none !important;
    user-select:none;
    -webkit-user-select:none;
    -webkit-touch-callout:none;
    -webkit-tap-highlight-color: transparent;
    transform: translateZ(0);
  }
  #stickBase{
    width:140px;height:140px;left:22px;bottom:22px;
    background:rgba(40,40,40,.55);
    border:2px solid rgba(255,255,255,.25);
  }
  #stickKnob{
    width:74px;height:74px;left:22px;bottom:22px;
    background:rgba(0,0,0,.65);
    border:2px solid rgba(255,255,255,.20);
  }

  #shootBtn{
    position:fixed;width:120px;height:120px;
    right:22px;bottom:28px;border-radius:50%;
    pointer-events:auto;
    touch-action:none !important;
    -webkit-touch-callout:none;
    -webkit-user-select:none;
    user-select:none;
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    transform: translateZ(0);
    -webkit-appearance:none;
    appearance:none;
    outline:none;

    background:radial-gradient(circle at 30% 30%,rgba(255,255,255,.35),rgba(255,0,0,.9));
    border:2px solid rgba(255,255,255,.25);
  }
  #shootLabel{
    position:fixed;right:22px;bottom:160px;
    color:#fff;font:800 14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    padding:6px 10px;border:2px solid rgba(255,255,255,.25);
    border-radius:10px;background:rgba(0,0,0,.45);pointer-events:none;
  }

  @media (pointer: fine) {
    /* マウス主体の端末では仮想コントローラ非表示 */
    .controls{display:none;}
  }
</style>
</head>
<body>
<canvas id="cv"></canvas>

<div id="hud">
  SCORE <span id="score">0</span> /
  WAVE <span id="wave">1</span><br>
  LIFE <span id="life">❤️❤️❤️</span>
</div>

<button id="pauseBtn" type="button">PAUSE</button>
<div id="msg"></div>

<div class="controls" id="controls">
  <div id="stickBase"></div>
  <div id="stickKnob"></div>
  <button id="shootBtn" type="button" aria-label="shoot"></button>
  <div id="shootLabel">SHOT</div>
</div>

<script>
/* =========================
   iOS Safari (Smart Zoom) 完全抑止
========================= */
['gesturestart','gesturechange','gestureend','dblclick'].forEach(t=>{
  document.addEventListener(t, e=>e.preventDefault(), {passive:false});
});
// shootBtn上のタッチはズーム等を確実に抑止
['touchstart','touchmove','touchend'].forEach(t=>{
  document.addEventListener(t, e=>{
    if(e.target && e.target.id==='shootBtn') e.preventDefault();
  }, {passive:false});
});

/* =========================
   基本設定
========================= */
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d", { alpha:false });

function resizeCanvas(){ cv.width = innerWidth; cv.height = innerHeight; }
resizeCanvas();

function calcU(){ if (innerWidth>=1200) return 7; if (innerWidth>=800) return 6; return 4; }
let U = calcU();
let isMobile = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);

function getCols(){ return 11; }
function getRows(){ return 5; }

const scoreEl = document.getElementById("score");
const waveEl  = document.getElementById("wave");
const lifeEl  = document.getElementById("life");
const msgEl   = document.getElementById("msg");

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function aabb(ax,ay,aw,ah,bx,by,bw,bh){
  return !(ax+aw<bx || ax>bx+bw || ay+ah<by || ay>by+bh);
}

/* =========================
   ポーズ
========================= */
const pauseBtn = document.getElementById("pauseBtn");
let paused = false;
let msgBeforePause = "";

function setPaused(next){
  if(over) return;
  paused = !!next;
  pauseBtn.textContent = paused ? "RESUME" : "PAUSE";
  if(paused){
    msgBeforePause = msgEl.innerHTML;
    msgEl.textContent = "PAUSED";
    holdL = false; holdR = false;
    stopShooting(); stickReset(); canShoot = true;
  }else{
    if(msgBeforePause && msgBeforePause!=="PAUSED") msgEl.innerHTML = msgBeforePause;
    else msgEl.textContent = "";
    msgBeforePause = "";
  }
}
function togglePause(){ setPaused(!paused); }
pauseBtn.addEventListener("click", (e)=>{ e.preventDefault(); togglePause(); }, {passive:false});

/* =========================
   スプライト
========================= */
const SHIP = [
  "000010000","000111000","000111000",
  "011111110","111111111","111111111","111111111"
];

const ENEMY_TYPES = [
  { a:["0100010","1111111","1011101","0100010"], b:["0100010","1111111","0101010","1010101"] },
  { a:["0011100","0111110","1101011","0111110"], b:["0011100","1111111","0101010","1010101"] },
  { a:["0110110","1111111","0101010","1010101"], b:["0011100","0111110","1101011","0111110"] },
  { a:["0011100","1111111","1010101","0100010"], b:["0011100","0111110","0101010","1010101"] }
];

const SHIELD = [
  "00111100","01111110","11111111","11111111","11111111","11000011"
];

function drawBitmap(lines, x, y, scale, color){
  ctx.fillStyle = color;
  for(let r=0;r<lines.length;r++){
    const row = lines[r];
    for(let c=0;c<row.length;c++){
      if(row[c]==="1") ctx.fillRect(x+c*scale, y+r*scale, scale, scale);
    }
  }
}

/* =========================
   色
========================= */
function shieldColor(){ return "#ff3333"; }
function playerColor(){ return "#44ff88"; }
const ROW_COLORS = ["#ff4d4d","#ffb84d","#ffff4d","#4dff4d","#4dd2ff"];

/* =========================
   サイズ
========================= */
let shipW=0, shipH=0, enemyW=0, enemyH=0, shieldW=0, shieldH=0;

function recalcSizes(){
  shipW = SHIP[0].length * U;
  shipH = SHIP.length * U;

  const cols = getCols();
  const margin = 12;
  const minGapX = 0.90*U;
  const availW = Math.max(120, innerWidth - margin*2);
  const maxEnemyW = (availW - (cols-1)*minGapX) / cols;
  const scale = isMobile ? 0.78 : 0.86;
  const targetW = maxEnemyW * scale;

  enemyW = clamp(targetW, 2.6*U, 5.5*U);
  enemyH = enemyW * (4/7);

  shieldW = 8*U;
  shieldH = 6*U;
}
recalcSizes();

/* =========================
   背景スター
========================= */
let stars = [];
function resetStars(){
  stars = [...Array(120)].map(()=>({x:Math.random()*innerWidth,y:Math.random()*innerHeight,s:0.6+Math.random()*1.2}));
}
resetStars();

/* =========================
   ゲーム状態
========================= */
let score=0, wave=1, life=3;
let ready=true, clearing=false, over=false;
let invincible=0, safeTimer=0;
let canShoot=true;
let holdL=false, holdR=false;

function updateLifeHud(){ lifeEl.textContent = "❤️".repeat(Math.max(0, life)); }

/* =========================
   自機
========================= */
const playerBottomPx = 70;
let px = innerWidth/2;

function playerTopY(){ return innerHeight - playerBottomPx - shipH; }
function clampPlayer(){ px = clamp(px, shipW/2, innerWidth - shipW/2); }

/* =========================
   敵隊列
========================= */
let cols = getCols(), rows = getRows();
let fx=0, fy=0, dir=1;
let enemyInitialCount = 0;
let enemyFrame = 0, enemyAnimTick = 0, enemyShootTick = 0;
let moveAcc = 0, wallPause = 0;
let aliveGrid = [];

function formationMetrics(){
  const minGapX = 0.90*U, minGapY = 1.10*U;
  const stepX = enemyW + minGapX;
  const stepY = enemyH + minGapY;
  const totalW = cols*enemyW + (cols-1)*minGapX;
  const baseY = Math.max(90, innerHeight*0.22);
  return { stepX, stepY, totalW, baseY };
}

function countAlive(){
  let n=0;
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(aliveGrid[r][c]) n++;
  return n;
}

function spawnEnemies(){
  cols = getCols(); rows = getRows();
  aliveGrid = Array.from({length:rows}, ()=>Array.from({length:cols}, ()=>true));
  const { totalW, baseY } = formationMetrics();
  fx = (innerWidth - totalW)/2; fy = baseY; dir = 1;
  enemyInitialCount = rows*cols;
  moveAcc = 0; wallPause = 0; enemyFrame = 0; enemyAnimTick = 0; enemyShootTick = 0;
}

/* =========================
   盾（シールド再配置入り）
========================= */
let shields = [];
function buildShieldBits(){
  const h = SHIELD.length, w = SHIELD[0].length;
  const bits = Array.from({length:h}, (_,r)=>Array.from({length:w},(_,c)=>SHIELD[r][c]==="1"));
  return {bits,w,h};
}

function computeShieldLayout(){
  const topMin = 40;            // 画面上の最低ライン
  const gapFromPlayer = 14;     // 自機との最低距離
  const defaultOffset = 80;     // 従来の -80

  const playerY = playerTopY();
  let y = playerY - defaultOffset;

  const maxY = playerY - shieldH - gapFromPlayer;
  y = Math.min(y, maxY);
  y = Math.max(y, topMin);

  if(maxY < topMin){
    y = Math.max(0, maxY);
  }

  const xs = [0.2,0.4,0.6,0.8];
  return xs.map(v => ({ x: innerWidth * v - shieldW/2, y }));
}

function spawnShields(){
  shields = [];
  const proto = buildShieldBits();
  const layout = computeShieldLayout();
  for(let i=0;i<layout.length;i++){
    const {x,y} = layout[i];
    const bits = proto.bits.map(row=>row.slice());
    shields.push({x,y,bits,w:proto.w,h:proto.h});
  }
}

function relayoutShields(){
  if(!shields.length){
    spawnShields();
    return;
  }
  const layout = computeShieldLayout();
  for(let i=0;i<shields.length && i<layout.length;i++){
    shields[i].x = layout[i].x;
    shields[i].y = layout[i].y;
  }
}

function shieldHitAndDamage(bx,by,bw,bh){
  for(const s of shields){
    if(!aabb(bx,by,bw,bh, s.x,s.y, shieldW,shieldH)) continue;
    const rx = clamp(Math.floor(((bx+bw/2)-s.x)/U),0,s.w-1);
    const ry = clamp(Math.floor(((by+bh/2)-s.y)/U),0,s.h-1);
    const cand=[];
    for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
      const cx=rx+dx, cy=ry+dy;
      if(cy>=0&&cy<s.h&&cx>=0&&cx<s.w&&s.bits[cy][cx]) cand.push([cy,cx]);
    }
    if(cand.length){
      const [cy,cx]=cand[(Math.random()*cand.length)|0];
      s.bits[cy][cx]=false;
    }
    return true;
  }
  return false;
}

/* =========================
   弾・爆発
========================= */
const bullets=[], ebullets=[];
const BW=4, BH=10;
const booms=[];
function boom(x,y){
  for(let i=0;i<10;i++) booms.push({x,y,vx:(Math.random()-.5)*5,vy:(Math.random()-.5)*5,t:18});
}

/* =========================
   射撃
========================= */
function shoot(){
  if(paused) return;
  if(ready||clearing||over||!canShoot) return;
  canShoot=false;
  bullets.push({x:px-BW/2,y:playerTopY(),v:-10});
}

/* ★変更：Waveで「頻度UP」「同時弾数UP」「バースト発射」 */
function enemyProfile(){
  // 発射間隔：Waveが上がるほど短く（=頻度増）
  const fireInterval = Math.max(18, Math.floor(140 - (wave-1) * 8));

  // 同時に存在できる敵弾の上限：Waveごとに増える
  const maxBullets = Math.min(12, 2 + Math.floor((wave-1) / 4));

  // 1回の発射で追加する弾数（バースト）
  const burst = Math.min(3, 1 + Math.floor((wave-1) / 6));

  return { fireInterval, maxBullets, burst };
}

function enemyShoot(){
  if(paused) return;
  if(ready||clearing||over) return;

  const prof = enemyProfile();
  if(ebullets.length >= prof.maxBullets) return;

  const alive=[];
  for(let r=0;r<rows;r++)for(let c=0;c<cols;c++) if(aliveGrid[r][c]) alive.push([r,c]);
  if(!alive.length) return;

  const [r,c]=alive[(Math.random()*alive.length)|0];
  const {stepX,stepY}=formationMetrics();
  const ex=fx+c*stepX, ey=fy+r*stepY;

  // 弾速もWaveで少しUP（上がりすぎ防止）
  const baseV = (isMobile ? 5 : 7);
  const v = baseV + Math.min(4, (wave-1) * 0.2);

  const shots = Math.min(prof.burst, prof.maxBullets - ebullets.length);
  for(let k=0;k<shots;k++){
    const spread = (k - (shots-1)/2) * (BW + 2); // -?,0,+?
    ebullets.push({x:ex+enemyW/2-BW/2 + spread, y:ey+enemyH, v});
  }
}

/* =========================
   READY / CLEAR / GAMEOVER
========================= */
function showReady(){
  clearTimeout(window._msgTimer);
  if(!paused) msgEl.textContent="";
  ready=true; safeTimer=Math.floor(wave*0.5*60);
  window._msgTimer=setTimeout(()=>{ if(!over&&!paused) msgEl.textContent=""; ready=false; },900);
}
function nextWave(){
  clearing=true; if(!paused) msgEl.textContent="CLEAR!";
  setTimeout(()=>{
    if(paused) return;
    msgEl.textContent=""; wave++; waveEl.textContent=wave; clearing=false;
    spawnEnemies(); spawnShields(); showReady();
  },900);
}
function gameOver(){
  if(over) return;
  over=true; paused=false; pauseBtn.textContent="PAUSE";
  msgEl.innerHTML="GAME OVER<br>Tap or Enter";
}

/* =========================
   リセット
========================= */
function reset(){
  bullets.length=0; ebullets.length=0; booms.length=0;
  msgEl.textContent="";
  score=0; wave=1; life=3; invincible=0; safeTimer=0; over=false; clearing=false;
  paused=false; pauseBtn.textContent="PAUSE"; msgBeforePause="";
  stopShooting(); stickReset();
  scoreEl.textContent="0"; waveEl.textContent="1"; updateLifeHud();
  px=innerWidth/2; clampPlayer();
  spawnEnemies(); spawnShields(); showReady();
}

/* =========================
   ロジック
========================= */
function updateLogic(dt){
  if(paused) return;

  for(const s of stars){
    s.y+=s.s*(dt*0.06);
    if(s.y>innerHeight){s.y=0;s.x=Math.random()*innerWidth;}
  }

  if(invincible>0) invincible--;
  if(safeTimer>0) safeTimer--;

  const sp=isMobile?3:4;
  if(!ready&&!clearing&&!over){
    if(holdL) px-=sp;
    if(holdR) px+=sp;
  }
  clampPlayer();

  const {totalW}=formationMetrics();
  const remaining=Math.max(1,countAlive());
  const initialCount=enemyInitialCount||remaining;
  const ratio=remaining/initialCount;

  // ★変更：Waveで移動が「少しずつ」加速（速くなりすぎ防止あり）
  const baseInterval=260, minInterval=70;
  let moveInterval = baseInterval*ratio + minInterval*(1-ratio);
  const waveSpeedMul = 1 / (1 + (wave-1) * 0.04);
  moveInterval = Math.max(45, moveInterval * waveSpeedMul);

  const stepMoveX=0.55*U*(1+(wave-1)*0.02);
  const stepDown=0.60*U;
  const wallPauseMs=140;

  if(!ready&&!clearing&&!over){
    moveAcc+=dt;
    if(wallPause>0){
      const use=Math.min(wallPause,moveAcc);
      wallPause-=use; moveAcc-=use;
    }
    while(moveAcc>=moveInterval){
      moveAcc-=moveInterval;
      const margin=10;
      const nextFx=fx+dir*stepMoveX;
      const nextLeft=nextFx, nextRight=nextFx+totalW;
      if(nextRight>innerWidth-margin||nextLeft<margin){
        dir*=-1;
        const enemyMaxY=playerTopY()-120;
        const stepYFix=7*U;
        const maxFy=enemyMaxY-(rows-1)*stepYFix;
        fy=Math.min(fy+stepDown,maxFy);
        wallPause=wallPauseMs;
      }else fx=nextFx;
    }
  }

  enemyAnimTick++;
  if(enemyAnimTick>=28){ enemyAnimTick=0; enemyFrame=1-enemyFrame; }

  if(!ready&&!clearing&&!over){
    const prof=enemyProfile();
    enemyShootTick++;
    if(enemyShootTick>=prof.fireInterval){
      enemyShootTick=0; enemyShoot();
    }
  }

  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i]; b.y+=b.v*(dt*0.06);
    if(b.y<-20) bullets.splice(i,1);
  }
  for(let i=ebullets.length-1;i>=0;i--){
    const b=ebullets[i]; b.y+=b.v*(dt*0.06);
    if(b.y>innerHeight+30) ebullets.splice(i,1);
  }

  for(let i=booms.length-1;i>=0;i--){
    const p=booms[i]; p.x+=p.vx; p.y+=p.vy; p.t--;
    if(p.t<=0) booms.splice(i,1);
  }
}

function detectCollisions(){
  if(paused) return;

  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    if(shieldHitAndDamage(b.x,b.y,BW,BH)) bullets.splice(i,1);
  }
  for(let i=ebullets.length-1;i>=0;i--){
    const b=ebullets[i];
    if(shieldHitAndDamage(b.x,b.y,BW,BH)) ebullets.splice(i,1);
  }

  const {stepX,stepY}=formationMetrics();
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    const c=Math.floor((b.x-fx)/stepX);
    const r=Math.floor((b.y-fy)/stepY);
    if(r>=0&&r<rows&&c>=0&&c<cols&&aliveGrid[r][c]){
      const ex=fx+c*stepX, ey=fy+r*stepY;
      if(aabb(b.x,b.y,BW,BH,ex,ey,enemyW,enemyH)){
        aliveGrid[r][c]=false; bullets.splice(i,1);
        boom(ex+enemyW/2,ey+enemyH/2);
        score+=100; scoreEl.textContent=score;
        if(countAlive()===0&&!over&&!clearing) nextWave();
      }
    }
  }

  if(!over){
    const pl=px-shipW/2, pt=playerTopY();
    for(let i=ebullets.length-1;i>=0;i--){
      const b=ebullets[i];
      if(aabb(b.x,b.y,BW,BH,pl,pt,shipW,shipH)){
        ebullets.splice(i,1);
        if(invincible===0&&safeTimer===0){
          life--; updateLifeHud(); boom(px,pt+shipH/2); invincible=60;
          if(life<=0) gameOver();
        }
      }
    }
  }
}

function render(){
  ctx.fillStyle="#000"; ctx.fillRect(0,0,innerWidth,innerHeight);

  ctx.fillStyle="#fff";
  for(const s of stars) ctx.fillRect(s.x,s.y,2,2);

  const sc=shieldColor();
  for(const s of shields){
    ctx.fillStyle=sc;
    for(let r=0;r<s.h;r++)for(let c=0;c<s.w;c++)
      if(s.bits[r][c]) ctx.fillRect(s.x+c*U,s.y+r*U,U,U);
  }

  const {stepX,stepY}=formationMetrics();
  for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){
    if(!aliveGrid[r][c]) continue;
    const type=ENEMY_TYPES[r%ENEMY_TYPES.length];
    const bmp=enemyFrame?type.b:type.a;
    const color=ROW_COLORS[r%ROW_COLORS.length];
    const x=fx+c*stepX, y=fy+r*stepY;
    const scale=Math.max(1,Math.round(enemyW/7));
    drawBitmap(bmp,x,y,scale,color);
  }

  drawBitmap(SHIP,px-shipW/2,playerTopY(),U,playerColor());

  ctx.fillStyle="cyan"; for(const b of bullets) ctx.fillRect(b.x,b.y,BW,BH);
  ctx.fillStyle="orange"; for(const b of ebullets) ctx.fillRect(b.x,b.y,BW,BH);
  ctx.fillStyle="orange"; for(const p of booms) ctx.fillRect(p.x,p.y,4,4);

  if(paused){
    ctx.fillStyle="rgba(0,0,0,.25)";
    ctx.fillRect(0,0,innerWidth,innerHeight);
  }
}

/* =========================
   PC入力（A発射のみ / Space無効）
========================= */
addEventListener("keydown",(e)=>{
  if(e.key==="p"||e.key==="P"||e.key==="Escape"){ togglePause(); return; }
  if(paused) return;
  if(over && e.key==="Enter") reset();

  if(e.code==="ArrowLeft") holdL=true;
  if(e.code==="ArrowRight") holdR=true;

  if(e.code==="KeyA") shoot();
});
addEventListener("keyup",(e)=>{
  if(paused) return;
  if(e.code==="ArrowLeft") holdL=false;
  if(e.code==="ArrowRight") holdR=false;
  if(e.code==="KeyA") canShoot=true;
});

/* =========================
   モバイル：アナログスティック＋SHOT（touch専用）
========================= */
const controls=document.getElementById("controls");
const stickBase=document.getElementById("stickBase");
const stickKnob=document.getElementById("stickKnob");
const shootBtn=document.getElementById("shootBtn");

let stick={baseCx:0,baseCy:0,radius:52,dx:0};
let stickTouchActive=false;

function setKnobPos(x,y){
  const w=stickKnob.offsetWidth||74, h=stickKnob.offsetHeight||74;
  stickKnob.style.left=(x-w/2)+"px";
  stickKnob.style.top=(y-h/2)+"px";
}
function updateStickGeometry(){
  const r=stickBase.getBoundingClientRect();
  stick.baseCx=r.left+r.width/2;
  stick.baseCy=r.top+r.height/2;
}
function applyStick(){
  const dead=0.18;
  if(Math.abs(stick.dx)<dead){ holdL=false; holdR=false; return; }
  if(stick.dx<0){ holdL=true; holdR=false; }
  else{ holdR=true; holdL=false; }
}
function stickReset(){
  stickTouchActive=false; stick.dx=0;
  holdL=false; holdR=false;
  updateStickGeometry();
  setKnobPos(stick.baseCx, stick.baseCy);
}

function stickMoveTouch(t){
  const vx = t.clientX - stick.baseCx;
  const len = Math.abs(vx);
  const max = stick.radius;
  const cl = Math.min(len, max);
  const dx = vx < 0 ? -cl : cl;

  setKnobPos(stick.baseCx + dx, stick.baseCy);

  stick.dx = clamp(vx / max, -1, 1);
  applyStick();
}

stickBase.addEventListener("touchstart",(e)=>{
  if(!isMobile||paused||over) return;
  stickTouchActive=true;
  updateStickGeometry();
  if(e.touches && e.touches[0]) stickMoveTouch(e.touches[0]);
  e.preventDefault(); e.stopPropagation();
},{passive:false});

stickKnob.addEventListener("touchstart",(e)=>{
  if(!isMobile||paused||over) return;
  stickTouchActive=true;
  updateStickGeometry();
  if(e.touches && e.touches[0]) stickMoveTouch(e.touches[0]);
  e.preventDefault(); e.stopPropagation();
},{passive:false});

window.addEventListener("touchmove",(e)=>{
  if(!stickTouchActive||paused) return;
  if(e.touches && e.touches[0]) stickMoveTouch(e.touches[0]);
  e.preventDefault(); e.stopPropagation();
},{passive:false});

function endStickTouch(e){
  if(!stickTouchActive) return;
  stickReset();
  e.preventDefault(); e.stopPropagation();
}
window.addEventListener("touchend", endStickTouch, {passive:false});
window.addEventListener("touchcancel", endStickTouch, {passive:false});

/* SHOT連射 */
let shootInterval=null;
function startShooting(){
  if(paused) return;
  if(over){ reset(); return; }
  canShoot=true; shoot();
  stopShooting();
  shootInterval=setInterval(()=>{
    if(paused||over) return;
    canShoot=true; shoot();
  },120);
}
function stopShooting(){
  if(shootInterval){ clearInterval(shootInterval); shootInterval=null; }
  canShoot=true;
}

shootBtn.addEventListener("touchstart",(e)=>{
  if(!isMobile||paused) return;
  shootBtn.blur();
  if(document.activeElement) document.activeElement.blur();
  startShooting();
  e.preventDefault(); e.stopPropagation();
},{passive:false});

function endShootTouch(e){
  stopShooting();
  e.preventDefault(); e.stopPropagation();
}
shootBtn.addEventListener("touchend", endShootTouch, {passive:false});
shootBtn.addEventListener("touchcancel", endShootTouch, {passive:false});

function updateControlsVisibility(){
  controls.style.display = isMobile ? 'block' : 'none';
  updateStickGeometry();
  setKnobPos(stick.baseCx, stick.baseCy);
}
updateControlsVisibility();

/* =========================
   resize（毎回relayoutShields）
========================= */
let resizeQueued=false;
addEventListener("resize",()=>{
  if(resizeQueued) return;
  resizeQueued=true;
  requestAnimationFrame(()=>{
    resizeQueued=false;
    resizeCanvas();
    const oldIsMobile=isMobile, oldCols=cols, oldRows=rows;
    U=calcU();
    isMobile = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
    recalcSizes();

    const bpChanged=(oldIsMobile!==isMobile)||(oldCols!==getCols())||(oldRows!==getRows());
    resetStars(); clampPlayer(); updateControlsVisibility();

    if(bpChanged){ reset(); return; }

    relayoutShields();

    const {totalW,baseY}=formationMetrics();
    fx=(innerWidth-totalW)/2; fy=baseY;
    if(paused) stickReset();
  });
});

/* =========================
   ループ
========================= */
function loop(){
  const now=performance.now();
  const dt=Math.min(34, now-(loop._last||now));
  loop._last=now;
  updateLogic(dt);
  detectCollisions();
  render();
  requestAnimationFrame(loop);
}

/* =========================
   START
========================= */
reset();
loop();
</script>
</body>
</html>
